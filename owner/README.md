# 소유권이란?

Rust 의 핵심기능은 **소유권**이라고 한다. 모든 프로그램은 실행하는 동안 컴퓨터의 메모리를 사용하는 방법을 관리해야 한다.
몇몇 언어들은 **GC 와 같은 것을 이용하여 메모리 사용**을 관리한다. 그리괴 **또 다른 언어(C 와 C++) 같은 언어들은 사용자가 직접적으로 메모리 관리**를 하기도 한다.
그럼 Rust 는? **Rust 는 컴파일 타임에 컴파일러가 체크할 규칙들로 구성된 시스템을 통해 관리**된다.

## Stack And Heap

자바나 자바스크립트 같은 고수준의 언어를 배우다보면 사실 Stack 과 Heap 에 스레드나 Object 들이 생긴다는 것 까지는 알 수 있지만, 이를 관리해본 경험은 거의 없을 것이다.
하지만 러스트에서는 어느정도는 아는 것이 좋다고 생각한다. 물론 저 두 언어에서도 어느정도 알기는 하는것이 좋다고 생각한다.

**스택과 힙 둘다 런타임에 사용할 수 있는 메모리의 일부**이다.

스택은 값을 받아들인 **순서대로 저장하고, 반대 방향으로 값을 지우는데, 이 덕분에 스택은 데이터를 넣어두기 위한 공간이나, 가져올 공간을 검색할 필요가 없습니다.**
스택을 더 빠르게 해주기 위해서는 스택이 동일한 크기를 지니고 있다면 훨씬 더 빨라질 수 있습니다.

따라서 컴파일 타입에 크기가 결정되어 지지 않는 것들은 보통 Heap 에 저장하게 됩니다.

먼져 힙에 넣을때 이곳이 사용중이냐고 묻고, 사용하지 않고 있으면 이곳에 넣을 수 없습니다. 그래서 컴퓨터는 사용중이지 않은 지점의 포인터를 사용중으로 바뀐 뒤 우리에게 돌려주고,
해당 지점에 데이터를 넣을 수 있도록 해줍니다.

위의 절차를 **힙 공간 할당하기** 라고 하며, 짧게는 **allocate** 라고도 부릅니다.

힙의 데이터는 스택에 붙게 되는것보다 느릴 수 밖에 없는데 이는 공간 지역성과 관계도 있습니다. 여하튼 Rust 에서 소유권이란 개념을 공부하게 되면, 힙을 관리하는 것이 소유권의 존재 이유임을 알게됩니다.

## 소유권 규칙

1. 러스트의 각각의 값은 해당값의 오너라고 불리우는 변수를 갖고 있다.
2. 한번에 딱 하나의 오너만 존재할 수 있다.
3. 오너가 스코프 밖으로 벗어나는 때, 값은 버려진다.

이해 가기 힘들 수도 있으니 아래의 코드를 보면서 이해해보자

```rust
fn main() { // 유효하지 않음

    let s = "hello"; // 유효하기 시작한 시점

} // 유효하지 않음
```

위의 s 라는 변수의 스코프를 나타낸 것이다. 해당 s 라는 변수는 유효 기간을 나타낸 것이다.
다른 언어와 비슷하다. 근데 계속해서 짚고 유의깊게 봐야할점은 아래와 같다.

1. **스코프 안에서 s 가 등장하면 유효합니다.**
2. **이 유효기간은 스코프 밖으로 벗어나기 전까지 유효합니다.**

## 문자열은 불변

모든 언어에서 문자열은 보통 **immutable** 이다. 잘 생각해라, `String b = "hello"` 와 같은 것에서 "hello" 라는 문자열은 immutable 이다.
그렇다면 immutable 한 값은 사이즈가 정해져 있으므로 Stack 에 저장할 수 있을 것이다.
그런데 우리가 데이터를 받아올 수도 있고, 어느정도 사이즈의 크기인지 감이 안올때가 있을 것이다. 예를 들면 사용자 입력을 받아야 한다던가.
이럴때를 위해서 보통의 언어처럼 `String` 이라는 타입을 지원해준다.

```rust
let mut s = String::from("hello");

s.push_str(", world!");

print!("{}", s);
```

왜 **String 으로 저렇게 만들면 동적으로 되고, "hello" 라고 하면, 불변으로 되지않느냐를 봤을때** 아래와 같다.
우리가 `s = "hello"` 같이 사용한 것들은 이미 컴파일 시점에 내용물을 알 수 있기에, **더 빠르고 효율적으로 사용할 수 있게끔 최적화**를 할 수 있다.
하지만 **이 모든 전제는 문자열이 immutable 하다는 전제 하에 이루어지는 것**이다.

그래서 String 은 런타임에 어느정도 값을 받을 수 있도록 사이즈가 설계되었다. **따라서 런타임에 크기를 알 수 있으므로, 런타임에 운영체제로 부터 메모리 할당을 요청**한다.
**두번째로는 받아간 메모리를 어느시점에 메모리에 반환해야 하는지 생각하는 것과 반환할 방법이 필요**하다.

첫번째는 위에서 말했듯 GC 를 이용할 수 있을 것이고, 두번째도 위에서 말했듯이 C 언어 처럼 직접 반환해줄 수도 있을 것이다.

그럼 Rust 의 방식을 보자, Rust 는 아래와 같은 방식을 이용한다.

```rust
{
    let mut s = String::from("hello");

    s.push_str(", world!");

    print!("{}", s);
} // 변수 s 소멸
```

Rust 는 변수가 스코프를 벗어나는 순간 소멸된다. 이때 `drop` 이라는 함수가 호출되는데 이는 메모리에 반환한다는 뜻이다.

```rust
let s1 = String::from("hello");
let s2 = s1;
```

위와 같은 코드를 치면 아래와 같은 구조를 지니게 된다.

![image](https://user-images.githubusercontent.com/57784077/128502393-5568217f-3c8d-4dff-81d1-20f228815ea2.png)

즉 s2 애 s1 을 대입하면, 이는 Stack 에 있는 포인터, 길이, 용량만 복사될 뿐이지. 포인터가 가르키고 있는 데이터가 복사되는 구조가 아니라는 것입니다.

만약 아래와 같이 다르게 힙영역이 분리가 된다면

![image](https://user-images.githubusercontent.com/57784077/128502600-14542a4b-c7c8-47a2-ba04-599e180b6751.png)

이는 equal 과정에서 비교하기 위해 Rust 가 이곳저곳 열심히 뛰어야 하기에 전자의 사진보다 명백히 느릴 것 입니다.

그런데 이 사진을 보여준 이유는 무엇일까요. 바로위의 사진말고, 두 변수가 하나의 힙메모리 영역을 가르치고 있는 걸 봅시다.

만약 s1 의 scope 가 끝나서 "hello" 영역에 drop 이 작동된다고 할때, s2 는 계속 쓰이게 되는데 가르켜줄 주소상의 값들이 사라지게 됩니다.
또한 도잇에 스코프 밖으로 벗어나려고 할시, 둘다 메모리를 해제하려고 들것입니다. 이는 메모리에 두번 해제를 일으킬 수 있으며 이는 메모리 손상의 원인이 됩니다.

근데 Rust 는 이를 막기 위해서, 유효하지 않은 것으로 간주해버리는데 백문이 불여일타라고 아래의 코드를 한번 보자

```rust
let s1 = String::from("hello");
let s2 = s1;

println!("{}, world!", s1);
```

![image](https://user-images.githubusercontent.com/57784077/128503157-7fe20848-eff1-41d2-9049-9b827563c2f5.png)

위의 사진을 보라.. 진짜 컴파일에서 이런걸 잡아내는 언어라니 난생 놀랍다. 여하튼 **s2 에 s1 을 넣는데 너는 왜 s1 을 쓰려고 들어!
그러다 메모리 두번 해제하게 되면 메모리에 손상이 일어날 수 있으니깐 컴파일도 하지마!** 이런 느낌이다.

Rust 는 이를 s1 을 무효화 시킨 뒤 s2 를 사용해라 라고 하는 것을 s1 이 s2 로 이동했다. 라고 표현하여 `move` 라고 한다.
근데 이걸 하면서 느낀게, 내가 자바를 하면서도 코드를 막쳤던 것이 생각보다 문제를 일으킬 수도 있겠구나? 이런 생각이 들었다.

만약 진짜로 사용해야 된다면, 우리는 깊은 복사를 이용해야 할것이다.

```rust
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);
```

위와 같은 구조는 깊은 복사를 단행하므로 잘 작동할 것이다. 메모리 상에서의 구조는 아래와 같을 것이다.

![image](https://user-images.githubusercontent.com/57784077/128502600-14542a4b-c7c8-47a2-ba04-599e180b6751.png)

## 소유권과 함수

함수에게 값을 넘긴다는 것은 의미론적으로 해당 값을 변수에 대입한다는 것과 비슷하다. 따라서 move 되거나 복사될 것이다.
아래의 코드를 보자, 당신은 아래의 코드가 정상적으로 실행된다라고 보는가?

```
fn main() {

    let s = String::from("hello");

    take_ownership(s);

    println!("Is Playes : {} ?" , s);

    let x = 5;

    makes_copy(5);

}

fn take_ownership(some_string: String) {
    println!("{}", some_string);
}

fn makes_copy(some_integer: i32) {
    println!("{}", some_integer);
}
```

**땡!** 러스트는 정상적으로 실행되지 않는다. 왜냐? **s 를 take_ownership 에 넣었으므로, 해당 변수는 take_ownership 안으로 move 해버렸다.**
즉 scope 는 저곳에서 종료되었다.

![image](https://user-images.githubusercontent.com/57784077/128504243-3d494ac6-4ea9-40d3-acbd-da8891a66156.png)
